# Decisions and Compromises
1. Using Viewsets- Easy to implement without much code. Best practice for maintaining a clean codebase and not reinventing the wheel. The functionalities were mostly CRUD and this comes out of the bod with  `ModelViewSets`. 
This also aided in the URL routing too. Very minimal code implemented to generate all relevant routes
2. Using a `base_model` Model- I noticed that there were  fields that were common in all models and thus, in line wth best principles of DRY(Do not Repeat Yourself), I chose to develop a base model with the common fields where all other models would inherit from.
3. Using `IntegerField()`- In the api docs description, the fields that would seem to be foreign keys are designated as Integers. Also, the relationship between the `subscription` field in `App` model and the `app` field in `Subscription` model is cyclic. With this situation, I chose to represent the fields as Integers on the assumption that the API consumer(Front end) would be the entity to ensure the numbers entered are valid foreign keys. 
If I were to do validation in the backend, I would use `pre_save` Django model signals and before saving the integers, I would do a validation check to ensure the integer(ID) exists in the parent table being referenced. eg, in Subscription, that the plan id exists in the plan table. If it exists, it is saved. If not, a `ReferentialIntegrityError` exception is raised. This would be an extra layer to ensure data sanity and validity in the backend should the front end fail to implement.

The alternative would be to use Foreign keys, follow conventions and drop the subscription field in the App model to avoid the cyclic referencing, and use something like a `to_representation()` function or `StringRelatedField`in the model serializers to customize the output of the serializer and cater to the Foreign key relation.
4. Testing- The tests are bundles per Model for easier referencing and grouping. Each model has a `test_get`, `test_create` and `test_url`. These are the main components. Should the project grow exponentially, I would breakout the tests and have each test in its own file. creates, urls and gets. On a larger scale, this form of logical grouping is better since one can even apply DRY principles and have a master `test_get` stencil which would be a function and allows parameters from the different models.
